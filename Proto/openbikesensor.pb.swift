// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: openbikesensor.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Openbikesensor_Time: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sourceID: Int32 = 0

  /// Timestamp in seconds and nanoseconds since the reference time. 
  var seconds: Int64 = 0

  var nanoseconds: Int32 = 0

  var reference: Openbikesensor_Time.Reference = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Reference: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unspecified // = 0

    /// The source clock has no real-world reference, or its real-world
    /// reference is unknown.
    case arbitrary // = 1

    /// The source clock is referencing UTC time relative to the unix epoch.
    case unix // = 2

    /// The source clock is referencing GPS time since its epoch 1980-01-06. The
    /// week number is converted to seconds and added to the seconds part.
    case gps // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .arbitrary
      case 2: self = .unix
      case 3: self = .gps
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .arbitrary: return 1
      case .unix: return 2
      case .gps: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Openbikesensor_Time.Reference] = [
      .unspecified,
      .arbitrary,
      .unix,
      .gps,
    ]

  }

  init() {}
}

struct Openbikesensor_DistanceMeasurement: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique ID for the source device of this measurement. Check your device
  /// manual for interpretation of this value (e. g. left/right mapping).
  var sourceID: Int32 = 0

  /// The distance measured, in meters.
  var distance: Float = 0

  /// A fraction (0..1) that represents the quality of this measurment, or the
  /// degree of certainty for this value to be accurate.
  var quality: Float = 0

  /// The raw time of flight measured (if applicable) in nanoseconds. Depending
  /// on sensor type, converting this to a distance with additional information
  /// (if available) may be more accurate than the provided distance (e. g.
  /// speed of sound depends on temperature and pressure). It is assumed that
  /// the type of sensor (sound, light) is known or can be derived.
  var timeOfFlight: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Openbikesensor_TextMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Openbikesensor_TextMessage.TypeEnum = .unspecified

  var text: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unspecified // = 0
    case debug // = 1
    case info // = 2
    case warning // = 3
    case error // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .debug
      case 2: self = .info
      case 3: self = .warning
      case 4: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .debug: return 1
      case .info: return 2
      case .warning: return 3
      case .error: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Openbikesensor_TextMessage.TypeEnum] = [
      .unspecified,
      .debug,
      .info,
      .warning,
      .error,
    ]

  }

  init() {}
}

struct Openbikesensor_Geolocation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sourceID: Int32 = 0

  /// Position on WSG84 in degrees, same as
  /// https://github.com/googleapis/googleapis/blob/master/google/type/latlng.proto
  var latitude: Double = 0

  var longitude: Double = 0

  /// Altitude above mean sea level, in meters.
  var altitude: Double = 0

  /// ground speed, in meters per second
  var groundSpeed: Float = 0

  /// degrees clockwise from true north
  var heading: Float = 0

  /// number of visible satellites
  var satellites: Int32 = 0

  /// HDOP value from GPS
  var hdop: Float = 0

  /// in decibels ?
  var signalNoiseRatio: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Openbikesensor_UserInput: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The mapping of the button that was pressed.
  var type: Openbikesensor_UserInput.TypeEnum = .userInputTypeUnspecified

  var timing: Openbikesensor_UserInput.Timing = .userInputTimingUnspecified

  var direction: Openbikesensor_UserInput.Direction = .unspecified

  /// A string describing the addon action.
  var addon: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case userInputTypeUnspecified // = 0

    /// == Core functionality ==
    case overtaker // = 1
    case oncomingTraffic // = 2

    /// Conflict with another traffic participant. The conflict may be of any
    /// nature, such as a complicated situation on shared infrastructure that
    /// required slowdown or stopping.
    case conflict // = 10
    case conflictPedestrian // = 11
    case conflictBycycle // = 12
    case conflictVehicle // = 13
    case uncomfortableSituation // = 14
    case dangerousSituation // = 15
    case collision // = 16
    case accident // = 17

    /// to mark something that the sensors might consider a "situation" otherwise
    case noSituation // = 18
    case usingCycleway // = 20
    case usingRoad // = 21
    case usingFootpath // = 22

    /// == Recording control ==
    case track // = 81

    /// timing=IMMEDIATE -> toggle pause
    case pause // = 83

    /// timing=IMMEDIATE -> toggle private
    case modePrivate // = 86
    case invalidatePreviousInput // = 88
    case manualEditingRequired // = 89

    /// == Parking and dooring ==
    case parkedVehicle // = 100
    case parkedVehicleObstacle // = 102
    case parkedVehicleEndangerment // = 103
    case dooringZone // = 104

    /// == Traffic situation ==
    case trafficLight // = 120
    case trafficLightRed // = 121
    case trafficLightGreen // = 122
    case congestion // = 123
    case emergencyVehicle // = 124
    case construction // = 125
    case passingQueue // = 126
    case tailgating // = 127
    case addon // = 200
    case UNRECOGNIZED(Int)

    init() {
      self = .userInputTypeUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .userInputTypeUnspecified
      case 1: self = .overtaker
      case 2: self = .oncomingTraffic
      case 10: self = .conflict
      case 11: self = .conflictPedestrian
      case 12: self = .conflictBycycle
      case 13: self = .conflictVehicle
      case 14: self = .uncomfortableSituation
      case 15: self = .dangerousSituation
      case 16: self = .collision
      case 17: self = .accident
      case 18: self = .noSituation
      case 20: self = .usingCycleway
      case 21: self = .usingRoad
      case 22: self = .usingFootpath
      case 81: self = .track
      case 83: self = .pause
      case 86: self = .modePrivate
      case 88: self = .invalidatePreviousInput
      case 89: self = .manualEditingRequired
      case 100: self = .parkedVehicle
      case 102: self = .parkedVehicleObstacle
      case 103: self = .parkedVehicleEndangerment
      case 104: self = .dooringZone
      case 120: self = .trafficLight
      case 121: self = .trafficLightRed
      case 122: self = .trafficLightGreen
      case 123: self = .congestion
      case 124: self = .emergencyVehicle
      case 125: self = .construction
      case 126: self = .passingQueue
      case 127: self = .tailgating
      case 200: self = .addon
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .userInputTypeUnspecified: return 0
      case .overtaker: return 1
      case .oncomingTraffic: return 2
      case .conflict: return 10
      case .conflictPedestrian: return 11
      case .conflictBycycle: return 12
      case .conflictVehicle: return 13
      case .uncomfortableSituation: return 14
      case .dangerousSituation: return 15
      case .collision: return 16
      case .accident: return 17
      case .noSituation: return 18
      case .usingCycleway: return 20
      case .usingRoad: return 21
      case .usingFootpath: return 22
      case .track: return 81
      case .pause: return 83
      case .modePrivate: return 86
      case .invalidatePreviousInput: return 88
      case .manualEditingRequired: return 89
      case .parkedVehicle: return 100
      case .parkedVehicleObstacle: return 102
      case .parkedVehicleEndangerment: return 103
      case .dooringZone: return 104
      case .trafficLight: return 120
      case .trafficLightRed: return 121
      case .trafficLightGreen: return 122
      case .congestion: return 123
      case .emergencyVehicle: return 124
      case .construction: return 125
      case .passingQueue: return 126
      case .tailgating: return 127
      case .addon: return 200
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Openbikesensor_UserInput.TypeEnum] = [
      .userInputTypeUnspecified,
      .overtaker,
      .oncomingTraffic,
      .conflict,
      .conflictPedestrian,
      .conflictBycycle,
      .conflictVehicle,
      .uncomfortableSituation,
      .dangerousSituation,
      .collision,
      .accident,
      .noSituation,
      .usingCycleway,
      .usingRoad,
      .usingFootpath,
      .track,
      .pause,
      .modePrivate,
      .invalidatePreviousInput,
      .manualEditingRequired,
      .parkedVehicle,
      .parkedVehicleObstacle,
      .parkedVehicleEndangerment,
      .dooringZone,
      .trafficLight,
      .trafficLightRed,
      .trafficLightGreen,
      .congestion,
      .emergencyVehicle,
      .construction,
      .passingQueue,
      .tailgating,
      .addon,
    ]

  }

  enum Timing: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case userInputTimingUnspecified // = 0
    case immediate // = 1
    case start // = 2
    case end // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .userInputTimingUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .userInputTimingUnspecified
      case 1: self = .immediate
      case 2: self = .start
      case 3: self = .end
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .userInputTimingUnspecified: return 0
      case .immediate: return 1
      case .start: return 2
      case .end: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Openbikesensor_UserInput.Timing] = [
      .userInputTimingUnspecified,
      .immediate,
      .start,
      .end,
    ]

  }

  enum Direction: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case unspecified // = 0
    case around // = 1
    case left // = 2
    case right // = 3
    case forward // = 4
    case back // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .around
      case 2: self = .left
      case 3: self = .right
      case 4: self = .forward
      case 5: self = .back
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .around: return 1
      case .left: return 2
      case .right: return 3
      case .forward: return 4
      case .back: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Openbikesensor_UserInput.Direction] = [
      .unspecified,
      .around,
      .left,
      .right,
      .forward,
      .back,
    ]

  }

  init() {}
}

/// Arbitrary meta information for the track, the device or the recording. The
/// values can be interpreted as UTF-8 strings. Keys are application and
/// device specific. Common use cases include transmitting and storing
/// firmware version and settings, active modes, or rider statistics or
/// information.
struct Openbikesensor_Metadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Dictionary<String,Data> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Information about a battery in a recording device.
struct Openbikesensor_BatteryStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sourceID: Int32 = 0

  /// in range [0 .. 1]
  var chargeLevel: Float = 0

  /// in volts
  var voltage: Float = 0

  /// in amperes
  var current: Float = 0

  /// in seconds
  var timeRemaining: Int32 = 0

  var mode: Openbikesensor_BatteryStatus.Mode = .batteryStatusModeUnspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Mode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case batteryStatusModeUnspecified // = 0
    case charging // = 1
    case discharging // = 2
    case idle // = 3
    case unknown // = 4
    case unavailable // = 5
    case defective // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .batteryStatusModeUnspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .batteryStatusModeUnspecified
      case 1: self = .charging
      case 2: self = .discharging
      case 3: self = .idle
      case 4: self = .unknown
      case 5: self = .unavailable
      case 6: self = .defective
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .batteryStatusModeUnspecified: return 0
      case .charging: return 1
      case .discharging: return 2
      case .idle: return 3
      case .unknown: return 4
      case .unavailable: return 5
      case .defective: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [Openbikesensor_BatteryStatus.Mode] = [
      .batteryStatusModeUnspecified,
      .charging,
      .discharging,
      .idle,
      .unknown,
      .unavailable,
      .defective,
    ]

  }

  init() {}
}

struct Openbikesensor_Event: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This field should usually contain at least one time entry that allows
  /// referencing this message to a point in time. If the message contains
  /// multiple time entries from different references, this may be used to 
  /// synchronize clocks.
  var time: [Openbikesensor_Time] = []

  /// The packet may contain debug content, depending on the device and message
  /// type. This can be interpreted by developers who know the above and
  /// therefore know how to interpret this content. It is usually not used for
  /// evaluation of the data.
  var debug: Data = Data()

  var content: Openbikesensor_Event.OneOf_Content? = nil

  var distanceMeasurement: Openbikesensor_DistanceMeasurement {
    get {
      if case .distanceMeasurement(let v)? = content {return v}
      return Openbikesensor_DistanceMeasurement()
    }
    set {content = .distanceMeasurement(newValue)}
  }

  var textMessage: Openbikesensor_TextMessage {
    get {
      if case .textMessage(let v)? = content {return v}
      return Openbikesensor_TextMessage()
    }
    set {content = .textMessage(newValue)}
  }

  var geolocation: Openbikesensor_Geolocation {
    get {
      if case .geolocation(let v)? = content {return v}
      return Openbikesensor_Geolocation()
    }
    set {content = .geolocation(newValue)}
  }

  var userInput: Openbikesensor_UserInput {
    get {
      if case .userInput(let v)? = content {return v}
      return Openbikesensor_UserInput()
    }
    set {content = .userInput(newValue)}
  }

  var metadata: Openbikesensor_Metadata {
    get {
      if case .metadata(let v)? = content {return v}
      return Openbikesensor_Metadata()
    }
    set {content = .metadata(newValue)}
  }

  var batteryStatus: Openbikesensor_BatteryStatus {
    get {
      if case .batteryStatus(let v)? = content {return v}
      return Openbikesensor_BatteryStatus()
    }
    set {content = .batteryStatus(newValue)}
  }

  /// Addons may place their contents here.
  var addons: [Google_Protobuf_Any] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable, Sendable {
    case distanceMeasurement(Openbikesensor_DistanceMeasurement)
    case textMessage(Openbikesensor_TextMessage)
    case geolocation(Openbikesensor_Geolocation)
    case userInput(Openbikesensor_UserInput)
    case metadata(Openbikesensor_Metadata)
    case batteryStatus(Openbikesensor_BatteryStatus)

  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "openbikesensor"

extension Openbikesensor_Time: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Time"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}source_id\0\u{1}seconds\0\u{1}nanoseconds\0\u{1}reference\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sourceID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.seconds) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.nanoseconds) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.reference) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceID != 0 {
      try visitor.visitSingularInt32Field(value: self.sourceID, fieldNumber: 1)
    }
    if self.seconds != 0 {
      try visitor.visitSingularInt64Field(value: self.seconds, fieldNumber: 2)
    }
    if self.nanoseconds != 0 {
      try visitor.visitSingularInt32Field(value: self.nanoseconds, fieldNumber: 3)
    }
    if self.reference != .unspecified {
      try visitor.visitSingularEnumField(value: self.reference, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openbikesensor_Time, rhs: Openbikesensor_Time) -> Bool {
    if lhs.sourceID != rhs.sourceID {return false}
    if lhs.seconds != rhs.seconds {return false}
    if lhs.nanoseconds != rhs.nanoseconds {return false}
    if lhs.reference != rhs.reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openbikesensor_Time.Reference: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0REFERENCE_UNSPECIFIED\0\u{1}ARBITRARY\0\u{1}UNIX\0\u{1}GPS\0")
}

extension Openbikesensor_DistanceMeasurement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DistanceMeasurement"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}source_id\0\u{1}distance\0\u{1}quality\0\u{3}time_of_flight\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sourceID) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.distance) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.quality) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timeOfFlight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceID != 0 {
      try visitor.visitSingularInt32Field(value: self.sourceID, fieldNumber: 1)
    }
    if self.distance.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.distance, fieldNumber: 2)
    }
    if self.quality.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.quality, fieldNumber: 3)
    }
    if self.timeOfFlight != 0 {
      try visitor.visitSingularInt64Field(value: self.timeOfFlight, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openbikesensor_DistanceMeasurement, rhs: Openbikesensor_DistanceMeasurement) -> Bool {
    if lhs.sourceID != rhs.sourceID {return false}
    if lhs.distance != rhs.distance {return false}
    if lhs.quality != rhs.quality {return false}
    if lhs.timeOfFlight != rhs.timeOfFlight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openbikesensor_TextMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TextMessage"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}text\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openbikesensor_TextMessage, rhs: Openbikesensor_TextMessage) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openbikesensor_TextMessage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TYPE_UNSPECIFIED\0\u{1}DEBUG\0\u{1}INFO\0\u{1}WARNING\0\u{1}ERROR\0")
}

extension Openbikesensor_Geolocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Geolocation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}source_id\0\u{1}latitude\0\u{1}longitude\0\u{1}altitude\0\u{3}ground_speed\0\u{1}heading\0\u{2}\u{4}satellites\0\u{1}hdop\0\u{3}signal_noise_ratio\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sourceID) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.altitude) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.groundSpeed) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.heading) }()
      case 10: try { try decoder.decodeSingularInt32Field(value: &self.satellites) }()
      case 11: try { try decoder.decodeSingularFloatField(value: &self.hdop) }()
      case 12: try { try decoder.decodeSingularFloatField(value: &self.signalNoiseRatio) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceID != 0 {
      try visitor.visitSingularInt32Field(value: self.sourceID, fieldNumber: 1)
    }
    if self.latitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 2)
    }
    if self.longitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 3)
    }
    if self.altitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.altitude, fieldNumber: 4)
    }
    if self.groundSpeed.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.groundSpeed, fieldNumber: 5)
    }
    if self.heading.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.heading, fieldNumber: 6)
    }
    if self.satellites != 0 {
      try visitor.visitSingularInt32Field(value: self.satellites, fieldNumber: 10)
    }
    if self.hdop.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.hdop, fieldNumber: 11)
    }
    if self.signalNoiseRatio.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.signalNoiseRatio, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openbikesensor_Geolocation, rhs: Openbikesensor_Geolocation) -> Bool {
    if lhs.sourceID != rhs.sourceID {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.altitude != rhs.altitude {return false}
    if lhs.groundSpeed != rhs.groundSpeed {return false}
    if lhs.heading != rhs.heading {return false}
    if lhs.satellites != rhs.satellites {return false}
    if lhs.hdop != rhs.hdop {return false}
    if lhs.signalNoiseRatio != rhs.signalNoiseRatio {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openbikesensor_UserInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserInput"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}timing\0\u{1}direction\0\u{1}addon\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.timing) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.direction) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.addon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .userInputTypeUnspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.timing != .userInputTimingUnspecified {
      try visitor.visitSingularEnumField(value: self.timing, fieldNumber: 2)
    }
    if self.direction != .unspecified {
      try visitor.visitSingularEnumField(value: self.direction, fieldNumber: 3)
    }
    if !self.addon.isEmpty {
      try visitor.visitSingularStringField(value: self.addon, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openbikesensor_UserInput, rhs: Openbikesensor_UserInput) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.timing != rhs.timing {return false}
    if lhs.direction != rhs.direction {return false}
    if lhs.addon != rhs.addon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openbikesensor_UserInput.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0USER_INPUT_TYPE_UNSPECIFIED\0\u{1}OVERTAKER\0\u{1}ONCOMING_TRAFFIC\0\u{2}\u{8}CONFLICT\0\u{1}CONFLICT_PEDESTRIAN\0\u{1}CONFLICT_BYCYCLE\0\u{1}CONFLICT_VEHICLE\0\u{1}UNCOMFORTABLE_SITUATION\0\u{1}DANGEROUS_SITUATION\0\u{1}COLLISION\0\u{1}ACCIDENT\0\u{1}NO_SITUATION\0\u{2}\u{2}USING_CYCLEWAY\0\u{1}USING_ROAD\0\u{1}USING_FOOTPATH\0\u{2};TRACK\0\u{2}\u{2}PAUSE\0\u{2}\u{3}MODE_PRIVATE\0\u{2}\u{2}INVALIDATE_PREVIOUS_INPUT\0\u{1}MANUAL_EDITING_REQUIRED\0\u{2}\u{b}PARKED_VEHICLE\0\u{2}\u{2}PARKED_VEHICLE_OBSTACLE\0\u{1}PARKED_VEHICLE_ENDANGERMENT\0\u{1}DOORING_ZONE\0\u{2}\u{10}TRAFFIC_LIGHT\0\u{1}TRAFFIC_LIGHT_RED\0\u{1}TRAFFIC_LIGHT_GREEN\0\u{1}CONGESTION\0\u{1}EMERGENCY_VEHICLE\0\u{1}CONSTRUCTION\0\u{1}PASSING_QUEUE\0\u{1}TAILGATING\0\u{2}I\u{1}ADDON\0")
}

extension Openbikesensor_UserInput.Timing: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0USER_INPUT_TIMING_UNSPECIFIED\0\u{1}IMMEDIATE\0\u{1}START\0\u{1}END\0")
}

extension Openbikesensor_UserInput.Direction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DIRECTION_UNSPECIFIED\0\u{1}AROUND\0\u{1}LEFT\0\u{1}RIGHT\0\u{1}FORWARD\0\u{1}BACK\0")
}

extension Openbikesensor_Metadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Metadata"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}data\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openbikesensor_Metadata, rhs: Openbikesensor_Metadata) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openbikesensor_BatteryStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatteryStatus"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}source_id\0\u{3}charge_level\0\u{1}voltage\0\u{1}current\0\u{3}time_remaining\0\u{1}mode\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.sourceID) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.chargeLevel) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.voltage) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.current) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.timeRemaining) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sourceID != 0 {
      try visitor.visitSingularInt32Field(value: self.sourceID, fieldNumber: 1)
    }
    if self.chargeLevel.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.chargeLevel, fieldNumber: 2)
    }
    if self.voltage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.voltage, fieldNumber: 3)
    }
    if self.current.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.current, fieldNumber: 4)
    }
    if self.timeRemaining != 0 {
      try visitor.visitSingularInt32Field(value: self.timeRemaining, fieldNumber: 5)
    }
    if self.mode != .batteryStatusModeUnspecified {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openbikesensor_BatteryStatus, rhs: Openbikesensor_BatteryStatus) -> Bool {
    if lhs.sourceID != rhs.sourceID {return false}
    if lhs.chargeLevel != rhs.chargeLevel {return false}
    if lhs.voltage != rhs.voltage {return false}
    if lhs.current != rhs.current {return false}
    if lhs.timeRemaining != rhs.timeRemaining {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Openbikesensor_BatteryStatus.Mode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0BATTERY_STATUS_MODE_UNSPECIFIED\0\u{1}CHARGING\0\u{1}DISCHARGING\0\u{1}IDLE\0\u{1}UNKNOWN\0\u{1}UNAVAILABLE\0\u{1}DEFECTIVE\0")
}

extension Openbikesensor_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}time\0\u{1}debug\0\u{4}\u{7}distance_measurement\0\u{3}text_message\0\u{1}geolocation\0\u{3}user_input\0\u{1}metadata\0\u{3}battery_status\0\u{2}T\u{1}addons\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.time) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.debug) }()
      case 10: try {
        var v: Openbikesensor_DistanceMeasurement?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .distanceMeasurement(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .distanceMeasurement(v)
        }
      }()
      case 11: try {
        var v: Openbikesensor_TextMessage?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .textMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .textMessage(v)
        }
      }()
      case 12: try {
        var v: Openbikesensor_Geolocation?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .geolocation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .geolocation(v)
        }
      }()
      case 13: try {
        var v: Openbikesensor_UserInput?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .userInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .userInput(v)
        }
      }()
      case 14: try {
        var v: Openbikesensor_Metadata?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .metadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .metadata(v)
        }
      }()
      case 15: try {
        var v: Openbikesensor_BatteryStatus?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .batteryStatus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .batteryStatus(v)
        }
      }()
      case 99: try { try decoder.decodeRepeatedMessageField(value: &self.addons) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.time.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.time, fieldNumber: 2)
    }
    if !self.debug.isEmpty {
      try visitor.visitSingularBytesField(value: self.debug, fieldNumber: 3)
    }
    switch self.content {
    case .distanceMeasurement?: try {
      guard case .distanceMeasurement(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .textMessage?: try {
      guard case .textMessage(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .geolocation?: try {
      guard case .geolocation(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .userInput?: try {
      guard case .userInput(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .metadata?: try {
      guard case .metadata(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .batteryStatus?: try {
      guard case .batteryStatus(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    if !self.addons.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.addons, fieldNumber: 99)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Openbikesensor_Event, rhs: Openbikesensor_Event) -> Bool {
    if lhs.time != rhs.time {return false}
    if lhs.debug != rhs.debug {return false}
    if lhs.content != rhs.content {return false}
    if lhs.addons != rhs.addons {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
